
======= STATIC =======
 neu -static int numFriend : thì các đối tượng object(ps, ps1, ps2), Person(class) đều truy cập vào được
 neu -int numFriend : thì chỉ các đối tượng object(ps, ps1, ps2) truy cập vào được
 - static variable : biến static
 - instance variable : biến của 1 đối tượng cố định
 - static method : hàm static
 - instance method : hàm của 1 đối tượng cố định
 - static method chỉ gọi được biến static và các phương thức static khác.


 -static int dem = 0;
 + từ khóa "static" được sử dụng để chỉ định rằng một biến(int), phương thức(void) hoặc khối mã nào đó thuộc về lớp(Class) 
 chứ không phải đối tượng cụ thể được tạo từ lớp đó, nếu 1 phương thức có static, sẽ ko cần tạo Obj để truy cập vào phương thức

 + ngược lại nếu ko phải "static" thì nó thuộc về các đối tượng cụ thể bên trong "được tạo từ lớp đó" trong hàm Main 
 vd: (Person ps = new Person()) và (Person ps1 = new Person());

 - nếu truy cập vào ps.dem thì nó đang truy cập đến biến 'dem' của đối tượng ps,=> nó sẽ in ra giá trị hiện tại của biến dem trong ps
 => (non-static) : mỗi (đối tượng) của lớp sẽ có một bản sao riêng của biến đó.

- nếu muốn 2 phương thức truy nhập vào với nhau, thì nó phải cùng kiểu static

public static void work() : có từ khóa static, nghĩa là chúng thuộc về lớp(Class), chứ không phải các các đối tượng cụ thể của lớp
=> nó sẽ ko biết rằng lấy đối tượng nào, trong khi ta đang lấy 1 đối tượng cụ thể bên trong lớp để nêu nó ra


======= NEXTLINE() =======

 + Khi gặp dấu "Enter", phương thức nextLine() sẽ đọc dấu xuống dòng đó và 'trả về một chuỗi trống' => ko nhập tiếp 
 (nếu không có ký tự nào khác trước dấu xuống dòng)
 => nếu dùng nextline(), cần thêm sc.nextline() bỏ qua kí tự '\n';

 + Khi gặp dấu "Enter",phương thức next() sẽ bỏ qua dấu xuống dòng 
 và tiếp tục đọc dữ liệu tiếp theo từ vị trí đầu tiên của dòng mới => nhập tiếp

'\n' : nhưng next và nextLine() sẽ đọc hết  
'\n' : nhưng nextInt() sẽ ko đọc được và bỏ qua câu lệnh
 next() : sẽ ko đọc các từ sau dấu cách 


======= PACKAGE =======

 import package01.myObj : 
 Một gói trong Java được sử dụng để nhóm các lớp liên quan. Hãy nghĩ về nó như một thư mục trong một thư mục tập tin . 
 Chúng tôi sử dụng các gói để tránh xung đột tên và để viết mã dễ bảo trì hơn.


 - Các gói được chia thành hai loại:

 Gói do người dùng xác định (tạo gói của riêng bạn) : la gói người dùng tự tạo : package package01;
 import package01.myObj truy cập đến gói đó : import.[thumucphu.tenfile]

 └── root : thu muc chinh
   └── mypack : thu muc phu
     └── MyPackageClass.java : ten file

 Gói tích hợp (gói từ API Java) : la cac thu vien hay dung vd : import java.util.Scanner;
 java.util là một gói, còn Scanner là một lớp của java.util

import java.util.* nhập toàn bộ gói
 pov : java.util.Scanner hoặc các hàm thư viện (API) khác cũng nằm trong các thư viện hệ thống file khác

======= ACCES MODIFIER ======= // CÔNG CỤ SỬA ĐỔI TRUY CẬP
ví dụ cho 2 gói :
package 1 : A, B
package 2 : C, subA;
Và Sub A là con của A
 - Public : hiển thị trong tất cả các 'Class' trong tất cả các gói(ở bất cứ đâu)
 - Protected : hiển thị cho tất cả các 'Class' trong cùng một gói, hoặc các 'Class con' trong các gói khác
 - Default : hiển thị cho tất cả các 'Class' trong cùng một gói ((default : biến bình thường'String, int,...'))
 - Private : Chỉ hiện thị trong cùng 1 'Class',(cùng 1 file);

======= TÍNH TRỪU TƯỢNG =======

- abstract class vehicle{ : lớp trừu tượng
- class Car extends vehicle{ : lớp kế thừa

vd: bạn vào cửa hàng bán xe, và hỏi nhân viên là muốn mua một chiếc xe, mà nó có thể chay, nghe vậy rất chung chung
=> chúng ta cần đến lớp trừu tượng để hiện thị "thông tin chính" cần thiết cho nhân viên 
 chẳng hạn như loại xe bạn quan tâm, mục đích sử dụng, yêu cầu về hiệu suất, và nhiều yếu tố khác.

Trừu tượng hóa dữ liệu là quá trình ẩn một số chi tiết nhất định và chỉ hiển thị thông tin cần thiết cho người dùng.
Sự trừu tượng hóa có thể đạt được bằng các lớp hoặc giao diện trừu tượng

Từ abstractkhóa là một công cụ sửa đổi không truy cập, được sử dụng cho các lớp và phương thức:

Lớp trừu tượng: là lớp bị hạn chế, không thể sử dụng để tạo đối tượng (để truy cập nó phải được kế thừa từ lớp khác).
Vehicle vh = new vehicle() : ko được

Phương thức trừu tượng: chỉ có thể được sử dụng trong một lớp trừu tượng và nó không có phần thân. 
Phần thân được cung cấp bởi lớp con (được kế thừa từ).
Một lớp trừu tượng có thể có cả phương thức trừu tượng và phương thức thông thường

Tại sao và khi nào nên sử dụng các lớp và phương thức trừu tượng?
Để đạt được bảo mật - hãy ẩn một số chi tiết nhất định và chỉ hiển thị các chi tiết quan trọng của một đối tượng.

======= Encapsulation ======= // tính đóng gói

Ý nghĩa của Encapsulation là đảm bảo rằng dữ liệu "nhạy cảm" được ẩn khỏi người dùng. Để đạt được điều này, bạn phải:

khai báo các biến/thuộc tính của lớp là private
cung cấp các phương thức get và set công khai để truy cập và cập nhật giá trị của một private biến
Phương get thức trả về giá trị biến và set phương thức đặt giá trị.

+Tại sao đóng gói?
Kiểm soát tốt hơn các thuộc tính và phương thức của lớp
Thuộc tính lớp có thể được đặt ở dạng chỉ đọc (nếu bạn chỉ sử dụng phương thức get) hoặc chỉ ghi (nếu bạn chỉ sử dụng phương thức set)
Linh hoạt: lập trình viên có thể thay đổi một phần code mà không ảnh hưởng đến các phần khác
Tăng cường bảo mật dữ liệu

======= Interface ======= // giao diện

Một cách khác để đạt được tính trừu tượng trong Java là sử dụng các 'Interface'.
interface là một " lớp trừu tượng " hoàn toàn được sử dụng để nhóm các phương thức liên quan với phần thân trống

Để truy cập các phương thức 'Interface', 'Interface' phải được "triển khai" (giống như được kế thừa) bởi một lớp khác gọi là implements (thay vì extends). 
Phần thân của phương thức 'Interface' được cung cấp bởi lớp "triển khai"  // ý nói là lớp con giống kế thừa

Giống như các lớp trừu tượng , các 'Interface' không thể được sử dụng để tạo đối tượng, giống trừu tượng
Các phương thức 'Interface' không có phần thân - phần thân được cung cấp bởi lớp "triển khai"
Khi triển khai một 'Interface', bạn phải ghi đè tất cả các phương thức của nó
Các phương thức 'Interface' theo mặc định abstract và public
Các thuộc tính 'Interface' theo mặc định publicvà staticfinal
Một 'Interface' không thể chứa hàm tạo (vì nó không thể được sử dụng để tạo đối tượng)
Tại sao và khi nào nên sử dụng 'Interface'?
Để đạt được bảo mật - hãy ẩn một số chi tiết nhất định và chỉ hiển thị các chi tiết quan trọng của một đối tượng (Interface)

Java không hỗ trợ "đa kế thừa" (một lớp chỉ có thể kế thừa từ một siêu lớp). 
Tuy nhiên, điều này có thể đạt được bằng các "Interface", vì lớp có thể triển khai nhiều "Interface".
Lưu ý: Mỗi lớp triển khai chỉ kế thừa 1 'Interface', Để triển khai nhiều "Interface", hãy phân tách chúng bằng dấu phẩy.

=======  polymorphism ======= // đa hình
Đa hình có nghĩa là "nhiều dạng" và nó xảy ra khi chúng ta có nhiều lớp có liên quan với nhau bằng tính kế thừa. <==========

Kế thừa cho phép chúng ta kế thừa các thuộc tính và phương thức từ một lớp khác. 
Đa hình sử dụng những phương pháp đó để thực hiện các nhiệm vụ khác nhau.
Điều này cho phép chúng ta thực hiện một hành động theo nhiều cách khác nhau.

Ví dụ, hãy nghĩ về một siêu lớp có tên Animal là có một phương thức gọi là animalSound(). 
Các lớp Động vật có thể là Lợn, Mèo, Chó, Chim - Và chúng cũng có cách thực hiện âm thanh động vật riêng (tiếng lợn kêu và tiếng mèo kêu, v.v.):
  + đa hình và kế thừa giống nhau
  + Đa hình sử dụng những phương pháp của kế thừa để thực hiện các nhiệm vụ khác nhau

======= Kế thừa =======
Kế thừa là một khái niệm trong lập trình hướng đối tượng cho phép một lớp (class) 
có thể kế thừa các thuộc tính và phương thức từ lớp khác gọi là lớp cha (base class hoặc superclass).
Lớp con (subclass hoặc derived class) có thể mở rộng (hoặc mở rộng lại) các thuộc tính và phương thức của lớp cha, 
cũng như thêm mới các thuộc tính và phương thức của riêng nó.
Kế thừa giúp tái sử dụng mã nguồn và tạo ra một cấu trúc phân cấp cho các lớp, giúp quản lý mã nguồn một cách có tổ chức.

== overloaded == : là phương thức có cùng tên, nhưng tham số khác nhau // nạp chồng phương thức
Lưu ý: Nhiều phương thức có thể có cùng tên miễn là số lượng và/hoặc loại tham số khác nhau.

== override == : cho phép lớp con triển khai 1 phương thức riêng mà nó kế thừa từ lớp cha // ghi đè